/* eslint-disable max-lines */

/**
 * Generated by orval v6.28.2 üç∫
 * Do not edit manually.
 * Flashcards
 * Flashcards API
 * OpenAPI spec version: 1.0
 */

export type DecksControllerFindRandomCardInDeckParams = {
  previousCardId?: string
}

export type DecksControllerFindCardsInDeckParams = {
  answer?: string
  currentPage?: number
  itemsPerPage?: number
  orderBy?: null | string
  question?: string
}

export type DecksControllerFindAllV2OrderBy =
  (typeof DecksControllerFindAllV2OrderBy)[keyof typeof DecksControllerFindAllV2OrderBy]

// eslint-disable-next-line @typescript-eslint/no-redeclare,no-redeclare
export const DecksControllerFindAllV2OrderBy = {
  'authorname-asc': 'author.name-asc',
  'authorname-desc': 'author.name-desc',
  'cardsCount-asc': 'cardsCount-asc',
  'cardsCount-desc': 'cardsCount-desc',
  'created-asc': 'created-asc',
  'created-desc': 'created-desc',
  'name-asc': 'name-asc',
  'name-desc': 'name-desc',
  null: 'null',
  'updated-asc': 'updated-asc',
  'updated-desc': 'updated-desc'
} as const

export type DecksControllerFindAllV2Params = {
  /**
   * Filter by deck authorId
   */
  authorId?: string
  currentPage?: number
  itemsPerPage?: number
  maxCardsCount?: number
  minCardsCount?: number
  /**
   * Search by deck name
   */
  name?: string
  /**
 * A string that represents the name of the field to order by and the order direction.
The format is: "field_name-order_direction".
Available directions: "asc" and "desc".
 */
  orderBy?: DecksControllerFindAllV2OrderBy
}

export type DecksControllerFindAllV1OrderBy =
  (typeof DecksControllerFindAllV1OrderBy)[keyof typeof DecksControllerFindAllV1OrderBy]

// eslint-disable-next-line @typescript-eslint/no-redeclare,no-redeclare
export const DecksControllerFindAllV1OrderBy = {
  'authorname-asc': 'author.name-asc',
  'authorname-desc': 'author.name-desc',
  'cardsCount-asc': 'cardsCount-asc',
  'cardsCount-desc': 'cardsCount-desc',
  'created-asc': 'created-asc',
  'created-desc': 'created-desc',
  'name-asc': 'name-asc',
  'name-desc': 'name-desc',
  null: 'null',
  'updated-asc': 'updated-asc',
  'updated-desc': 'updated-desc'
} as const

export type DecksControllerFindAllV1Params = {
  /**
   * Filter by deck authorId
   */
  authorId?: string
  currentPage?: number
  itemsPerPage?: number
  maxCardsCount?: number
  minCardsCount?: number
  /**
   * Search by deck name
   */
  name?: string
  /**
 * A string that represents the name of the field to order by and the order direction.
The format is: "field_name-order_direction".
Available directions: "asc" and "desc".
 */
  orderBy?: DecksControllerFindAllV1OrderBy
}

export interface UpdateCardRequest {
  /**
   * @minLength 3
   * @maxLength 500
   */
  answer?: string
  /**
   * @minLength 0
   * @maxLength 0
   */
  answerImg?: Blob
  /**
   * @minLength 3
   * @maxLength 500
   */
  answerVideo?: string
  /**
   * @minLength 3
   * @maxLength 500
   */
  question?: string
  /**
   * @minLength 0
   * @maxLength 0
   */
  questionImg?: Blob
  /**
   * @minLength 3
   * @maxLength 500
   */
  questionVideo?: string
}

export interface SaveGradeRequest {
  cardId: string
  /**
   * @minimum 1
   * @maximum 5
   */
  grade: number
}

export interface Card {
  answer: string
  answerImg: string
  answerVideo: string
  created: string
  deckId: string
  id: string
  question: string
  questionImg: string
  questionVideo: string
  shots: number
  updated: string
  userId: string
}

export interface CreateCardRequest {
  /**
   * @minLength 3
   * @maxLength 500
   */
  answer: string
  /**
   * @minLength 0
   * @maxLength 0
   */
  answerImg?: string
  /**
   * @minLength 3
   * @maxLength 500
   */
  answerVideo?: string
  /**
   * @minLength 3
   * @maxLength 500
   */
  question: string
  /**
   * @minLength 0
   * @maxLength 0
   */
  questionImg?: string
  /**
   * @minLength 3
   * @maxLength 500
   */
  questionVideo?: string
}

export interface CardWithGrade {
  answer: string
  answerImg: string
  answerVideo: string
  created: string
  deckId: string
  grade: number
  id: string
  question: string
  questionImg: string
  questionVideo: string
  shots: number
  updated: string
  userId: string
}

export interface Deck {
  cardsCount: number
  /** @nullable */
  cover: null | string
  created: string
  id: string
  isPrivate: boolean
  name: string
  updated: string
  userId: string
}

export interface UpdateDeckRequest {
  /** Cover image (has to be sent inside FormData, does NOT accept base64) */
  cover?: Blob
  isPrivate?: boolean
  name?: string
}

export interface CreateDeckRequest {
  /** Cover image (has to be sent inside FormData, does NOT accept base64) */
  cover?: Blob
  /** Private decks are not visible to other users */
  isPrivate?: boolean
  /**
   * @minLength 3
   * @maxLength 30
   */
  name: string
}

export interface MinMaxCards {
  max: number
  min: number
}

export interface Pagination {
  currentPage: number
  itemsPerPage: number
  totalItems: number
  totalPages: number
}

export interface PaginatedCardsWithGrade {
  items: CardWithGrade[]
  pagination: Pagination
}

export interface PaginatedDecksWithMaxCardsCount {
  items: DeckWithAuthor[]
  maxCardsCount: number
  pagination: Pagination
}

export interface DeckAuthor {
  id: string
  name: string
}

export interface DeckWithAuthor {
  author: DeckAuthor
  cardsCount: number
  /** @nullable */
  cover: null | string
  created: string
  id: string
  isPrivate: boolean
  name: string
  updated: string
  userId: string
}

export interface PaginatedDecks {
  items: DeckWithAuthor[]
  pagination: Pagination
}

export interface ResetPasswordRequest {
  /**
   * @minLength 3
   * @maxLength 30
   */
  password: string
}

export interface RecoverPasswordRequest {
  /** User's email address */
  email: string
  /** HTML template to be sent in the email;
 ##name## will be replaced with the user's name; 
 ##token## will be replaced with the password recovery token */
  html?: string
  /** Email subject */
  subject?: string
}

export interface ResendVerificationEmailRequest {
  /** HTML template to be sent in the email;
 ##name## will be replaced with the user's name; 
 ##token## will be replaced with the password recovery token */
  html?: string
  /** Email subject */
  subject?: string
  userId: string
}

export interface EmailVerificationRequest {
  code: string
}

export interface RegistrationRequest {
  email: string
  /** HTML template to be sent in the email;
 ##name## will be replaced with the user's name; 
 ##token## will be replaced with the password recovery token */
  html?: string
  /**
   * @minLength 3
   * @maxLength 30
   */
  name?: string
  /**
   * @minLength 3
   * @maxLength 30
   */
  password: string
  /** Whether to send a confirmation email or not.
Defaults to false */
  sendConfirmationEmail?: boolean
  /** Email subject */
  subject?: string
}

export interface UpdateUserRequest {
  avatar?: Blob
  name?: string
}

export interface CreateUserRequest {
  /**
   * User's email address
   * @pattern /^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$/
   */
  email: string
  /**
   * @minLength 3
   * @maxLength 10
   */
  name: string
  /**
   * @minLength 6
   * @maxLength 20
   */
  password: string
}

export type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * Update current user data.
 * @summary Update user data
 */
export const authControllerUpdateUserData = (
  updateUserRequest: BodyType<UpdateUserRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  const formData = new FormData()

  if (updateUserRequest.avatar !== undefined) {
    formData.append('avatar', updateUserRequest.avatar)
  }
  if (updateUserRequest.name !== undefined) {
    formData.append('name', updateUserRequest.name)
  }

  return createInstance<User>(
    {
      data: formData,
      headers: { 'Content-Type': 'multipart/form-data' },
      method: 'PATCH',
      url: `/v1/auth/me`
    },
    options
  )
}

/**
 * Create a new user account
 * @summary Create a new user account
 */
export const authControllerRegistration = (
  registrationRequest: BodyType<RegistrationRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<User>(
    {
      data: registrationRequest,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      url: `/v1/auth/sign-up`
    },
    options
  )
}

/**
 * Verify user email
 * @summary Verify user email
 */
export const authControllerConfirmRegistration = (
  emailVerificationRequest: BodyType<EmailVerificationRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<void>(
    {
      data: emailVerificationRequest,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      url: `/v1/auth/verify-email`
    },
    options
  )
}

/**
 * Send verification email again
 * @summary Send verification email again
 */
export const authControllerResendVerificationEmail = (
  resendVerificationEmailRequest: BodyType<ResendVerificationEmailRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<void>(
    {
      data: resendVerificationEmailRequest,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      url: `/v1/auth/resend-verification-email`
    },
    options
  )
}

/**
 * Sign current user out
 * @summary Sign current user out
 */
export const authControllerLogout = (options?: SecondParameter<typeof createInstance>) => {
  return createInstance<void>({ method: 'POST', url: `/v1/auth/logout` }, options)
}

/**
 * Deprecated, use v2
 * @deprecated
 * @summary Deprecated, use v2
 */
export const authControllerRefreshToken = (options?: SecondParameter<typeof createInstance>) => {
  return createInstance<void>({ method: 'POST', url: `/v1/auth/refresh-token` }, options)
}

/**
 * Get new access token using refresh token
 * @summary Get new access token using refresh token
 */
export const authControllerRefreshTokenV2 = (options?: SecondParameter<typeof createInstance>) => {
  return createInstance<void>({ method: 'POST', url: `/v2/auth/refresh-token` }, options)
}

/**
 * Send password recovery email
 * @summary Send password recovery email
 */
export const authControllerRecoverPassword = (
  recoverPasswordRequest: BodyType<RecoverPasswordRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<void>(
    {
      data: recoverPasswordRequest,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      url: `/v1/auth/recover-password`
    },
    options
  )
}

/**
 * Reset password
 * @summary Reset password
 */
export const authControllerResetPassword = (
  token: string,
  resetPasswordRequest: BodyType<ResetPasswordRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<void>(
    {
      data: resetPasswordRequest,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      url: `/v1/auth/reset-password/${token}`
    },
    options
  )
}

/**
 * Deprecated. Use v2 in combination with /min-max-cards request
 * @deprecated
 * @summary Paginated decks list
 */
export const decksControllerFindAllV1 = (
  params?: DecksControllerFindAllV1Params,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<PaginatedDecksWithMaxCardsCount>(
    { method: 'GET', params, url: `/v1/decks` },
    options
  )
}

/**
 * Create a deck
 * @summary Create a deck
 */
export const decksControllerCreate = (
  createDeckRequest: BodyType<CreateDeckRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  const formData = new FormData()

  if (createDeckRequest.cover !== undefined) {
    formData.append('cover', createDeckRequest.cover)
  }
  formData.append('name', createDeckRequest.name)
  if (createDeckRequest.isPrivate !== undefined) {
    formData.append('isPrivate', createDeckRequest.isPrivate.toString())
  }

  return createInstance<DeckWithAuthor>(
    {
      data: formData,
      headers: { 'Content-Type': 'multipart/form-data' },
      method: 'POST',
      url: `/v1/decks`
    },
    options
  )
}

/**
 * Retrieve paginated decks list.
 * @summary Paginated decks list
 */
export const decksControllerFindAllV2 = (
  params?: DecksControllerFindAllV2Params,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<PaginatedDecks>({ method: 'GET', params, url: `/v2/decks` }, options)
}

/**
 * Retrieve the minimum and maximum amount of cards in a deck.
 * @summary Minimum and maximum amount of cards in a deck
 */
export const decksControllerFindMinMaxCards = (
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<MinMaxCards>({ method: 'GET', url: `/v2/decks/min-max-cards` }, options)
}

/**
 * Retrieve a deck by id
 * @summary Retrieve a deck by id
 */
export const decksControllerFindOne = (
  id: string,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<DeckWithAuthor>({ method: 'GET', url: `/v1/decks/${id}` }, options)
}

/**
 * Update a deck
 * @summary Update a deck
 */
export const decksControllerUpdate = (
  id: string,
  updateDeckRequest: BodyType<UpdateDeckRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  const formData = new FormData()

  if (updateDeckRequest.cover !== undefined) {
    formData.append('cover', updateDeckRequest.cover)
  }
  if (updateDeckRequest.name !== undefined) {
    formData.append('name', updateDeckRequest.name)
  }
  if (updateDeckRequest.isPrivate !== undefined) {
    formData.append('isPrivate', updateDeckRequest.isPrivate.toString())
  }

  return createInstance<DeckWithAuthor>(
    {
      data: formData,
      headers: { 'Content-Type': 'multipart/form-data' },
      method: 'PATCH',
      url: `/v1/decks/${id}`
    },
    options
  )
}

/**
 * Delete a deck
 * @summary Delete a deck
 */
export const decksControllerRemove = (
  id: string,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<Deck>({ method: 'DELETE', url: `/v1/decks/${id}` }, options)
}

/**
 * Retrieve paginated cards in a deck
 * @summary Retrieve cards in a deck
 */
export const decksControllerFindCardsInDeck = (
  id: string,
  params?: DecksControllerFindCardsInDeckParams,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<PaginatedCardsWithGrade>(
    { method: 'GET', params, url: `/v1/decks/${id}/cards` },
    options
  )
}

/**
 * Create card in a deck
 * @summary Create a card
 */
export const decksControllerCreateCardInDeck = (
  id: string,
  createCardRequest: BodyType<CreateCardRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  const formData = new FormData()

  formData.append('question', createCardRequest.question)
  formData.append('answer', createCardRequest.answer)
  if (createCardRequest.questionImg !== undefined) {
    formData.append('questionImg', createCardRequest.questionImg)
  }
  if (createCardRequest.answerImg !== undefined) {
    formData.append('answerImg', createCardRequest.answerImg)
  }
  if (createCardRequest.questionVideo !== undefined) {
    formData.append('questionVideo', createCardRequest.questionVideo)
  }
  if (createCardRequest.answerVideo !== undefined) {
    formData.append('answerVideo', createCardRequest.answerVideo)
  }

  return createInstance<Card>(
    {
      data: formData,
      headers: { 'Content-Type': 'multipart/form-data' },
      method: 'POST',
      url: `/v1/decks/${id}/cards`
    },
    options
  )
}

/**
 * Retrieve a random card in a deck. The cards priority is based on the grade
 * @summary Retrieve a random card
 */
export const decksControllerFindRandomCardInDeck = (
  id: string,
  params?: DecksControllerFindRandomCardInDeckParams,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<CardWithGrade>(
    { method: 'GET', params, url: `/v1/decks/${id}/learn` },
    options
  )
}

/**
 * Save the grade of a card
 * @summary Save the grade of a card
 */
export const decksControllerSaveGrade = (
  id: string,
  saveGradeRequest: BodyType<SaveGradeRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<CardWithGrade | void>(
    {
      data: saveGradeRequest,
      headers: { 'Content-Type': 'application/json' },
      method: 'POST',
      url: `/v1/decks/${id}/learn`
    },
    options
  )
}

/**
 * Get card by id
 * @summary Get card by id
 */
export const cardsControllerFindOne = (
  id: string,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<CardWithGrade>({ method: 'GET', url: `/v1/cards/${id}` }, options)
}

/**
 * Update partial card data
 * @summary Update card
 */
export const cardsControllerUpdate = (
  id: string,
  updateCardRequest: BodyType<UpdateCardRequest>,
  options?: SecondParameter<typeof createInstance>
) => {
  const formData = new FormData()

  if (updateCardRequest.questionImg !== undefined) {
    formData.append('questionImg', updateCardRequest.questionImg)
  }
  if (updateCardRequest.answerImg !== undefined) {
    formData.append('answerImg', updateCardRequest.answerImg)
  }
  if (updateCardRequest.question !== undefined) {
    formData.append('question', updateCardRequest.question)
  }
  if (updateCardRequest.answer !== undefined) {
    formData.append('answer', updateCardRequest.answer)
  }
  if (updateCardRequest.questionVideo !== undefined) {
    formData.append('questionVideo', updateCardRequest.questionVideo)
  }
  if (updateCardRequest.answerVideo !== undefined) {
    formData.append('answerVideo', updateCardRequest.answerVideo)
  }

  return createInstance<Card>(
    {
      data: formData,
      headers: { 'Content-Type': 'multipart/form-data' },
      method: 'PATCH',
      url: `/v1/cards/${id}`
    },
    options
  )
}

/**
 * Delete card by id
 * @summary Delete card by id
 */
export const cardsControllerRemove = (
  id: string,
  options?: SecondParameter<typeof createInstance>
) => {
  return createInstance<void>({ method: 'DELETE', url: `/v1/cards/${id}` }, options)
}

export type AuthControllerGetUserDataResult = NonNullable<
  Awaited<ReturnType<typeof authControllerGetUserData>>
>
export type AuthControllerUpdateUserDataResult = NonNullable<
  Awaited<ReturnType<typeof authControllerUpdateUserData>>
>

export type AuthControllerRegistrationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRegistration>>
>
export type AuthControllerConfirmRegistrationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerConfirmRegistration>>
>
export type AuthControllerResendVerificationEmailResult = NonNullable<
  Awaited<ReturnType<typeof authControllerResendVerificationEmail>>
>
export type AuthControllerLogoutResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLogout>>
>
export type AuthControllerRefreshTokenResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRefreshToken>>
>
export type AuthControllerRefreshTokenV2Result = NonNullable<
  Awaited<ReturnType<typeof authControllerRefreshTokenV2>>
>
export type AuthControllerRecoverPasswordResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRecoverPassword>>
>
export type AuthControllerResetPasswordResult = NonNullable<
  Awaited<ReturnType<typeof authControllerResetPassword>>
>
export type DecksControllerFindAllV1Result = NonNullable<
  Awaited<ReturnType<typeof decksControllerFindAllV1>>
>
export type DecksControllerCreateResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerCreate>>
>
export type DecksControllerFindAllV2Result = NonNullable<
  Awaited<ReturnType<typeof decksControllerFindAllV2>>
>
export type DecksControllerFindMinMaxCardsResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerFindMinMaxCards>>
>
export type DecksControllerFindOneResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerFindOne>>
>
export type DecksControllerUpdateResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerUpdate>>
>
export type DecksControllerRemoveResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerRemove>>
>
export type DecksControllerFindCardsInDeckResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerFindCardsInDeck>>
>
export type DecksControllerCreateCardInDeckResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerCreateCardInDeck>>
>
export type DecksControllerFindRandomCardInDeckResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerFindRandomCardInDeck>>
>
export type DecksControllerSaveGradeResult = NonNullable<
  Awaited<ReturnType<typeof decksControllerSaveGrade>>
>
export type CardsControllerFindOneResult = NonNullable<
  Awaited<ReturnType<typeof cardsControllerFindOne>>
>
export type CardsControllerUpdateResult = NonNullable<
  Awaited<ReturnType<typeof cardsControllerUpdate>>
>
export type CardsControllerRemoveResult = NonNullable<
  Awaited<ReturnType<typeof cardsControllerRemove>>
>
